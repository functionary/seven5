<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Seven5: Pontificate</title>
  <meta name="GENERATOR" content="Blackfriday Markdown Processor v1.1" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="css/base.css" />
</head>
<body>

<h1>Seven5: Pontificate</h1>

<p><nav>
    <ul>
        <li><a href="index.html">Intro</a></li>
        <li><a href="install.html">Install</a></li>
        <li><a href="develop.html">Develop</a></li>
        <li><a href="pontificate.html">Pontificate</a></li>
    </ul>
</nav></p>

<p>Here you will find snippets of text explaining why Seven5 is the cranky, <a href="http://gettingreal.37signals.com/ch04_Make_Opinionated_Software.php">opinionated</a>, single-minded beast that it is.  If this were Halo, Seven5 would be the father of three with the sniper rifle making life miserable for the sword wielding 12 year olds camping by the lifts.</p>

<h2>Convention, not configuration</h2>

<p>Seven5 uses conventions, not configuration, to manage how your web application will work.  Because we&rsquo;ve chosen one way to code and one way to deploy, most of the configuration jackassery goes away.  During development you will never write a configuration file.  During deployment you will only have to place your creds in predefined places and Bob&rsquo;s your uncle.</p>

<p>Conventions also allow us to stop the insanity of repeating ourselves in each layer of the stack.  So many web frameworks think that it&rsquo;s normal to code your data models in multiple places: ORM, API and Javascript.  Seven5 unifies the definition of data, API, events and the rest of the system and then flows that information out where necessary.</p>

<p>If you want flexibility, go write Apache configuration files.</p>

<h2>Data structures belong in RAM, not on disk</h2>

<p>We avoid disk storage for dynamic data because disk is slow, expensive to manage, and generally more trouble than it&rsquo;s worth in the age of server machines with metric tons of RAM.  Also, it&rsquo;s a fricking spinning platter of metal.  WTF?!?</p>

<p>99% of the world doesn&rsquo;t need relational databases and the other 1% fucks it up.  Because of snazzy ORMs that hide SQL, developers end up with relational databases simply because that&rsquo;s the easiest path in the web framework.</p>

<p>Seven5 makes a different strategy easy.  Your data model is just, well, your data model.  You use go&rsquo;s data structures and store them, unmodified, in a distributed flock of RAM called <a href="http://memcached.org/">memcached</a> using <a href="http://blog.golang.org/2011/03/gobs-of-data.html">gobs</a> because <a href="http://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> is a righteous dude.</p>

<p>If you&rsquo;re paranoid about your entire cluster crashing then rest assured, it&rsquo;s trivial to provision redundant memcacheds in different locales and to take snapshots.</p>

<h2>Design is for designers. Programming is for programmers.</h2>

<p>There was a time when the base materials of the web were simple enough that the &ldquo;front end&rdquo; of a web app could be produced by people who did not understand the &ldquo;back end&rdquo;.  This seemed like a good idea because real programmers were snobbish about crappy browsers and foisting off quirks mode junk seemed like a good idea.</p>

<p>Those days are dead and buried.</p>

<p>Today&rsquo;s browsers are more standardized so the pain of quirks is fading.  Today&rsquo;s standards are more complex and most designers would rather design than learn about CSS selectors and event binding.  Today&rsquo;s pages are programs and client side libraries like jQuery and YUI require honest to god programming.</p>

<p>Seven5 embraces this by unifying the entire stack around languages and tools made for programmers.  Let designers design and programmers program!</p>

<h2>Naming</h2>

<p>The framework is called Seven5 because the originator lives in Paris, France. All the postal codes for Paris, proper, begin with 75.  Besides, names don&rsquo;t matter that much.</p>

<p>The use of the strange pronounciation of guise is because it sounds cooler. Plus, the originator lives very close to the residence (compound?) of the  <a href="http://en.wikipedia.org/wiki/House_of_Guise">House de Guise</a> which is  pronounced in this way.   The English word that is spelled the same way comes from the rumor that a dis<em>guise</em> was used by the Duc an attempt to mask his involvement in the attempted assassination of  <a href="http://en.wikipedia.org/wiki/Gaspard_de_Coligny">Gaspard de Coligny</a> that lead directly to the  <a href="http://en.wikipedia.org/wiki/St._Bartholomew's_Day_massacre">St. Bartholomew&rsquo;s Day Massacre</a>. Web frameworks  may educate in many ways.</p>

<p>The use of the name  <a href="http://en.wikipedia.org/wiki/Poignard">Poignard</a> is because sharp, narrow tools  are often needed when working with web frameworks.  Such tools, correctly  applied, can be the killing stroke whereas huge, but relatively blunt, tools like Javascript often provide less death.  More death is better.</p>

<h2>Why Mongrel2</h2>

<h3>Production Reasons</h3>

<ul>
<li><p><a href="http://www.mongrel2.org">Mongrel2</a> is derived from mongrel.  Both of them have extremely well tested and secure http handling code.  Both are known to perform well under high load and to pass <a href="http://www.valgrind.org">valgrind</a>, so they do not leak memory.  It&rsquo;s solid.</p></li>

<li><p>Mongrel2 is friendly for deployment/operations and can be easily configured to work in a cluster.  Mongrel2 can also handle having clusters, not necessarily in the same configuration, that handle the requests for one or more applications deployed on the cluster.  It&rsquo;s scalable.</p></li>
</ul>

<h3>Testing Reasons</h3>

<ul>
<li><p>Test the &ldquo;front door&rdquo; not some other path.  In other words, the best tests  use the code path that is as close&mdash;or better yet identical too&ndash;the code path  that is used by the end-user.  Unit tests in Seven5 code through the exact same dispatching (sometimes called &ldquo;routing&rdquo;) as a request in a production deployment, even in a clustered deployment.</p></li>

<li><p>Mongrel is easy to configure and control programmatically.  Seven5  exploits this ability to allow the server to be configured based on its own conventions of how to develop a web application.  During development it  should never be necessary to touch a configuration file.  Seven5 also uses this ability to programmatically start or restart mongrel2 as needed to run the developer&rsquo;s web application.</p></li>
</ul>

<h1>Abandon all editing all ye who enter here</h1>

<h2>Testing Javascript Code In Go</h2>

<p>I&rsquo;m not really sure how to make this work in practice.  Here&rsquo;s a couple of examples of things I&rsquo;d like to write, written in english rather than as go  code:</p>

<blockquote>
<p>Set the contents of the username field to &ldquo;&rdquo;.  Verify that the continue button is disabled.</p>

<p>Set the contents of the username field to &ldquo;ian&rdquo;.  Verify that there is
a drop down present. If there is a dropdown present, verify that it has
exactly one item in it, with the contents &ldquo;iansmith.&rdquo;</p>
</blockquote>

<p>My goal would be that unit tests could be written in go, referencing the objects  used in the DSLs for CSS and HTML and somehow have it &ldquo;drive&rdquo; the Poignard  code through its paces.  I have the sense that the right way to do this is to have Poignard abstract the notion of JS events slightly and allow these to be  synthesized by the test harness.  I definitely do not want some crap like Selenium or other &ldquo;browser level&rdquo; test harnesses.  Seven5 went to a lot of trouble for  once and only once, and the tests should benefit as well.</p>

<p>Easy case: changing the go code in the DSL of CSS or HTML should cause immediate problems in the source code of the tests.  This is easy  because the go compiler can check this and your IDE will tell you about it  right away.  Because of the <code>JSGuise</code>, the now changed entities should cause  the JS code to fail horribly&ndash;but not until the first time you run it.</p>

<p>More difficult to see is how changes in the JS code can be reflected back to the go language tests automatically.  I suppose there are two basic options:</p>

<ul>
<li><p>Go code runs the show.  Since the go code is running the tests, it must be told about what/how to access <code>Poignard</code> functions, etc.  This leads to a once and only once violation since it requires that some entities be duplicated from the Javascript world to the go world.  This is not <em>uberbad</em> because the test code runs and checks that things are ok so if you make a mistake at least it gets caught fast.</p></li>

<li><p>Write some type of Javascript analysis tool and use that to make entites, at least functions, visible to the go level. There are some grammars  <a href="http://www.antlr.org/grammar/1153976512034/ecmascriptA3.g">laying around</a> that could be used to extract some things from Javascript source and make them visible to test code.</p></li>
</ul>

<p>Along this latter line, but without the analysis, perhaps there could be some  simple rules associated with Poignard code.  Roughly, &ldquo;Poignard can only respond to events&rdquo; and these are handled according to <em>blah</em> convention.  Then the test code could send synthetic events from the server to the  client to drive the JS code.  Similarly, JSGuise could output some &ldquo;testing functions&rdquo; that could be called from test code (via a network message to the  browser from the server).</p>

<h2>AJAX Stuff</h2>

<p>Mongrel2 <a href="https://gist.github.com/920729">already has</a> support for the WebSockets proposal by <a href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07">HyBi working group</a> as well as support for flash-based socket communication with JSON, XML, and blah blah blah.  We should get this for free via our mongrel2 connection.</p>

<p>Seven5 needs to exploit the client/server separation carefully to allow unit tests to drive both client and server.</p>

</body>
</html>
