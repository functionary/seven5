package seven5

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"seven5/util"
	"strings"
)

const MARKER = "@@@+++@@@"

//CommandResult is returned only when there has been a trapped panic.
type PanicResult struct {
	Error          bool
	Panic          bool
}

//Command represents the way to talk to command inside seven5.  The
//args parameter is a pointer to a structure generated by NewParam()
//and may be nil.  The return value is a pointer to the result structure
//generated by NewReturn() and cannot be null and must include at least
//a CommandResult.
type Command interface {
	//Exec is called to run the command inside seven5.  All the
	//parameters will have be unmarshallled and the return value
	//will be marshalled for transmission back to roadie.
	Exec(name string, cwd string,
		config *ApplicationConfig, request *http.Request,
		log util.SimpleLogger) interface{}
}

//Run is the equivalent of main for Seven5 when in development mode.  
//The real main uses a pill. The first arg is the command name, the
//second the directory to operate on, plus two json blobs for the
//application config and the request.
func RunCommand(commandName string, dir string, logLevel string, configJson string, reqJson string) (ret string) {
	var config ApplicationConfig
	var resultBuffer bytes.Buffer
	var logdataBuffer bytes.Buffer

	logger := util.NewHtmlLogger(util.LogLevelStringToLevel(logLevel), &logdataBuffer, false)

	//requests have to be treated specilaly, not using the "normal" path
	//of json decoding
	req, err := util.UnmarshalRequest(reqJson, logger)
	if err!=nil {
		logger.Error("Error decoding request structure inside seven5!")
		ret = createResultString(nil,logdataBuffer)
		return
	}

	//decode the app config
	decoder := json.NewDecoder(strings.NewReader(configJson))
	err=decoder.Decode(&config)
	if err!=nil {
		logger.Error("Error decoding application config inside seven5!")
		ret = createResultString(nil,logdataBuffer)
		return
	}

	//prep encoder
	encoder := json.NewEncoder(&resultBuffer)

	defer func() {
		if rec := recover(); rec != nil {
			var b bytes.Buffer
			for _, i := range []int{4, 5, 6, 7} {
				file, line := util.GetCallerAndLine(i)
				b.WriteString(fmt.Sprintf("%s:%d\n", file, line))
			}
			logger.DumpTerminal(util.ERROR, "Trapped 'Panic' processing command",
				b.String())
			ret = createResultString(nil, logdataBuffer)
		}
	}()

	cmd, ok := Seven5app[commandName]
	if ok {
		resultStruct := cmd.Exec(commandName, dir, &config, req, logger)
		err := encoder.Encode(resultStruct)
		if err != nil {
			logger.Error("Error encoding result: %s", err)
			ret = createResultString(nil, logdataBuffer)
			return
		}
	} else {
		logger.Error("unknown command to seven5:'%s'", commandName)
		ret = createResultString(nil, logdataBuffer)
		return
	}
	logger.Debug("command '%s' ran to completion, size of marshalled result %d bytes", 
		commandName, resultBuffer.Len())
	ret = createResultString(&resultBuffer,logdataBuffer)
	return
}

func createResultString(resultBuffer *bytes.Buffer, logDataBuffer bytes.Buffer) string {
	logData := logDataBuffer.String()
	result := ""
	if resultBuffer!=nil {
		result = resultBuffer.String()
	}
	return result + MARKER + logData
	
}