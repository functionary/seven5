package seven5

import (
	"bytes"
	"encoding/json"
	"fmt"
	"seven5/util"
	"strings"
	"net/http"
	"time"
)

const MARKER = "@@@+++@@@"

//CommandResult is the shared portion of all results coming back from Seven5.
//All results from Seven5 are either CommandResult or a struct that includes
//it.
type CommandResult struct {
	Error          bool
	Panic          bool
	TipMsg         string
	ProcessingTime time.Duration
}


//ErrorResult cerates a result that has an error in it.
func ErrorResult() CommandResult {
	return CommandResult{Error: true}
}

//Command represents the way to talk to command inside seven5.  The
//args parameter is a pointer to a structure generated by NewParam()
//and may be nil.  The return value is a pointer to the result structure
//generated by NewReturn() and cannot be null and must include at least
//a CommandResult.
type Command interface {
	//Exec is called to run the command inside seven5.  All the
	//parameters will have be unmarshallled and the return value
	//will be marshalled for transmission back to roadie.
	Exec(name string, cwd string,
		config *ApplicationConfig, request *http.Request, 
		log util.SimpleLogger) interface{}
}

//Run is the equivalent of main for Seven5 when in development mode.  
//The real main uses a pill. The first arg is the command name, the
//second the directory to operate on, plus two json blobs for the
//application config and the request.
func RunCommand(commandName string, dir string, configJson string, reqJson string) (ret string) {
	var config ApplicationConfig
	var resultBuffer bytes.Buffer
	var logdataBuffer bytes.Buffer

	logger := util.NewHtmlLogger(util.DEBUG, true, &logdataBuffer, false)

	//requests have to be treated specilaly, not using the "normal" path
	//of json decoding
	req := util.UnmarshalRequest(reqJson, logger)

	//decode the app config
	decoder := json.NewDecoder(strings.NewReader(configJson))
	decoder.Decode(&config)

	//prep encoder
	encoder := json.NewEncoder(&resultBuffer)

	//time the processing
	start := time.Now()

	defer func() {
		if rec := recover(); rec != nil {
			var r CommandResult
			r.Error = true
			r.Panic = true
			r.ProcessingTime = time.Since(start)
			var b bytes.Buffer
			b.WriteString("Trapped a panic in command processing:\n")
			for _, i := range []int{4, 5, 6, 7} {
				file, line := util.GetCallerAndLine(i)
				b.WriteString(fmt.Sprintf("%s:%d\n", file, line))
			}
			logger.DumpTerminal(b.String())
			encoder.Encode(&r)
			ret = resultBuffer.String() + MARKER + logdataBuffer.String()
		}
	}()

	cmd, ok := Seven5app[commandName]
	if ok {
		resultStruct := cmd.Exec(commandName, dir, &config, req, logger)
		encoder.Encode(resultStruct)
	} else {
		var myRes CommandResult
		myRes.Error = true
		myRes.ProcessingTime = time.Since(start)
		logger.Error("unknown command to seven5:%s", commandName)
		encoder.Encode(&myRes)
	}
	ret = resultBuffer.String() + MARKER + logdataBuffer.String()
	return
}
